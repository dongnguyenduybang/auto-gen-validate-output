
    import { validateQuoteMessage } from '../validates/quote-message/validate-quote-message';
    import fs from 'fs';
    import path from 'path';
    import { summarizeErrors, summaryFields, getTime } from '../helps/utils';
    import { executeBeforeAllSteps, executeDelete } from '../functions';
    import { resolveJsonVariables } from '../helps/get-resolve-variables';
    import { plainToClass } from 'class-transformer';
    import { QuoteMessageResponse } from '../dto-response/quote-message.response';
    import { validateAfterLogic } from '../validates/send-location/validate-send-location-after';

    describe('Testcase for quote-message', () => {
        let totalTests = 0;
        let passedLogic = 0;
        let failedTests = [];
        let logicTests = [];
        let passedTests = 0
        let passed200 = 0
        let headerRequest
        let testNumber
        let resolvedData

        beforeAll( async () => {

          await executeBeforeAllSteps(["mockUser('duybang12345',1, 0)","createChannel({{token}}, 'channel 1')","sendMessage({{token}}, 0, {{channelId}}, 'test123', 'ref')"])

          headerRequest = {"Content-Type":"application/json","x-session-token":"{{token}}","x-country-code":"VN"}
         
        })
        beforeEach( async () => {

          await executeBeforeAllSteps(undefined)
          
         
        })

        afterEach(async () => {

          const messageId = globalThis.globalVar.get("messageId");
          if (messageId) {
            const result = await executeBeforeAllSteps([
              `getMessage({{token}}, {{channelId}}, ${messageId})`,
            ]);
            const validateAfter = await validateAfterLogic(result, resolvedData)
            if (validateAfter.length === 0) {
              passedLogic++;
            } else {
              logicTests.push({ 
                testcase: testNumber,
                errorLogic: validateAfter
              });
            }
          }
        })

        
           
            it('Test case # 1 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 1;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 2 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 2;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 3 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 3;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 4 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 4;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 5 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 5;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 6 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 6;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 7 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 7;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 8 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 8;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 9 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty"] ', async () => {
             testNumber = 9;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 10 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 10;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 11 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 11;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 12 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty"] ', async () => {
             testNumber = 12;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 13 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 13;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 14 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 14;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 15 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 15;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 16 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 16;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 17 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 17;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 18 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 18;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 19 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 19;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 20 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 20;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 21 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string"] ', async () => {
             testNumber = 21;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 22 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 22;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 23 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 23;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 24 with expect errors ["workspaceId should not be empty","channelId should not be empty","messageId must be a string"] ', async () => {
             testNumber = 24;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 25 with expect errors ["workspaceId should not be empty","channelId should not be empty","content should not be empty"] ', async () => {
             testNumber = 25;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 26 with expect errors ["workspaceId should not be empty","channelId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 26;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 27 with expect errors ["workspaceId should not be empty","channelId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 27;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 28 with expect errors ["workspaceId should not be empty","channelId should not be empty","content should not be empty"] ', async () => {
             testNumber = 28;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 29 with expect errors ["workspaceId should not be empty","channelId should not be empty","content must be a string"] ', async () => {
             testNumber = 29;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 30 with expect errors ["workspaceId should not be empty","channelId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 30;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 31 with expect errors ["workspaceId should not be empty","channelId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 31;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 32 with expect errors ["workspaceId should not be empty","channelId should not be empty","content must be a string"] ', async () => {
             testNumber = 32;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 33 with expect errors ["workspaceId should not be empty","channelId should not be empty"] ', async () => {
             testNumber = 33;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 34 with expect errors ["workspaceId should not be empty","channelId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 34;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 35 with expect errors ["workspaceId should not be empty","channelId should not be empty","ref must be a string"] ', async () => {
             testNumber = 35;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 36 with expect errors ["workspaceId should not be empty","channelId should not be empty"] ', async () => {
             testNumber = 36;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 37 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 37;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 38 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 38;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 39 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 39;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 40 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 40;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 41 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 41;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 42 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 42;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 43 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 43;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 44 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 44;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 45 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty"] ', async () => {
             testNumber = 45;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 46 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 46;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 47 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 47;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 48 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId should not be empty"] ', async () => {
             testNumber = 48;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 49 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 49;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 50 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 50;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 51 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 51;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 52 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 52;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 53 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 53;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 54 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 54;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 55 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 55;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 56 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 56;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 57 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string"] ', async () => {
             testNumber = 57;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 58 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 58;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 59 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 59;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 60 with expect errors ["workspaceId should not be empty","channelId must be a string","messageId must be a string"] ', async () => {
             testNumber = 60;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 61 with expect errors ["workspaceId should not be empty","channelId must be a string","content should not be empty"] ', async () => {
             testNumber = 61;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 62 with expect errors ["workspaceId should not be empty","channelId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 62;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 63 with expect errors ["workspaceId should not be empty","channelId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 63;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 64 with expect errors ["workspaceId should not be empty","channelId must be a string","content should not be empty"] ', async () => {
             testNumber = 64;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 65 with expect errors ["workspaceId should not be empty","channelId must be a string","content must be a string"] ', async () => {
             testNumber = 65;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 66 with expect errors ["workspaceId should not be empty","channelId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 66;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 67 with expect errors ["workspaceId should not be empty","channelId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 67;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 68 with expect errors ["workspaceId should not be empty","channelId must be a string","content must be a string"] ', async () => {
             testNumber = 68;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 69 with expect errors ["workspaceId should not be empty","channelId must be a string"] ', async () => {
             testNumber = 69;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 70 with expect errors ["workspaceId should not be empty","channelId must be a string","ref should not be empty"] ', async () => {
             testNumber = 70;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 71 with expect errors ["workspaceId should not be empty","channelId must be a string","ref must be a string"] ', async () => {
             testNumber = 71;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 72 with expect errors ["workspaceId should not be empty","channelId must be a string"] ', async () => {
             testNumber = 72;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","channelId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 73 with expect errors ["workspaceId should not be empty","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 73;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 74 with expect errors ["workspaceId should not be empty","messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 74;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 75 with expect errors ["workspaceId should not be empty","messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 75;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 76 with expect errors ["workspaceId should not be empty","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 76;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 77 with expect errors ["workspaceId should not be empty","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 77;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 78 with expect errors ["workspaceId should not be empty","messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 78;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 79 with expect errors ["workspaceId should not be empty","messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 79;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 80 with expect errors ["workspaceId should not be empty","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 80;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 81 with expect errors ["workspaceId should not be empty","messageId should not be empty"] ', async () => {
             testNumber = 81;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 82 with expect errors ["workspaceId should not be empty","messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 82;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 83 with expect errors ["workspaceId should not be empty","messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 83;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 84 with expect errors ["workspaceId should not be empty","messageId should not be empty"] ', async () => {
             testNumber = 84;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 85 with expect errors ["workspaceId should not be empty","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 85;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 86 with expect errors ["workspaceId should not be empty","messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 86;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 87 with expect errors ["workspaceId should not be empty","messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 87;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 88 with expect errors ["workspaceId should not be empty","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 88;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 89 with expect errors ["workspaceId should not be empty","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 89;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 90 with expect errors ["workspaceId should not be empty","messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 90;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 91 with expect errors ["workspaceId should not be empty","messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 91;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 92 with expect errors ["workspaceId should not be empty","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 92;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 93 with expect errors ["workspaceId should not be empty","messageId must be a string"] ', async () => {
             testNumber = 93;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 94 with expect errors ["workspaceId should not be empty","messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 94;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 95 with expect errors ["workspaceId should not be empty","messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 95;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 96 with expect errors ["workspaceId should not be empty","messageId must be a string"] ', async () => {
             testNumber = 96;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 97 with expect errors ["workspaceId should not be empty","content should not be empty"] ', async () => {
             testNumber = 97;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 98 with expect errors ["workspaceId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 98;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 99 with expect errors ["workspaceId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 99;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 100 with expect errors ["workspaceId should not be empty","content should not be empty"] ', async () => {
             testNumber = 100;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 101 with expect errors ["workspaceId should not be empty","content must be a string"] ', async () => {
             testNumber = 101;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 102 with expect errors ["workspaceId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 102;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 103 with expect errors ["workspaceId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 103;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 104 with expect errors ["workspaceId should not be empty","content must be a string"] ', async () => {
             testNumber = 104;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 105 with expect errors ["workspaceId should not be empty"] ', async () => {
             testNumber = 105;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 106 with expect errors ["workspaceId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 106;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 107 with expect errors ["workspaceId should not be empty","ref must be a string"] ', async () => {
             testNumber = 107;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 108 with expect errors ["workspaceId should not be empty"] ', async () => {
             testNumber = 108;
              totalTests++;
              const payloadObj = {"workspaceId":"","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 109 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 109;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 110 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 110;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 111 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 111;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 112 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 112;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 113 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 113;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 114 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 114;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 115 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 115;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 116 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 116;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 117 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty"] ', async () => {
             testNumber = 117;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 118 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 118;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 119 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 119;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 120 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId should not be empty"] ', async () => {
             testNumber = 120;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 121 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 121;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 122 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 122;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 123 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 123;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 124 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 124;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 125 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 125;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 126 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 126;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 127 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 127;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 128 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 128;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 129 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string"] ', async () => {
             testNumber = 129;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 130 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 130;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 131 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 131;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 132 with expect errors ["workspaceId must be a string","channelId should not be empty","messageId must be a string"] ', async () => {
             testNumber = 132;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 133 with expect errors ["workspaceId must be a string","channelId should not be empty","content should not be empty"] ', async () => {
             testNumber = 133;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 134 with expect errors ["workspaceId must be a string","channelId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 134;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 135 with expect errors ["workspaceId must be a string","channelId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 135;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 136 with expect errors ["workspaceId must be a string","channelId should not be empty","content should not be empty"] ', async () => {
             testNumber = 136;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 137 with expect errors ["workspaceId must be a string","channelId should not be empty","content must be a string"] ', async () => {
             testNumber = 137;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 138 with expect errors ["workspaceId must be a string","channelId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 138;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 139 with expect errors ["workspaceId must be a string","channelId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 139;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 140 with expect errors ["workspaceId must be a string","channelId should not be empty","content must be a string"] ', async () => {
             testNumber = 140;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 141 with expect errors ["workspaceId must be a string","channelId should not be empty"] ', async () => {
             testNumber = 141;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 142 with expect errors ["workspaceId must be a string","channelId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 142;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 143 with expect errors ["workspaceId must be a string","channelId should not be empty","ref must be a string"] ', async () => {
             testNumber = 143;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 144 with expect errors ["workspaceId must be a string","channelId should not be empty"] ', async () => {
             testNumber = 144;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 145 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 145;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 146 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 146;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 147 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 147;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 148 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 148;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 149 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 149;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 150 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 150;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 151 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 151;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 152 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 152;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 153 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty"] ', async () => {
             testNumber = 153;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 154 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 154;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 155 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 155;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 156 with expect errors ["workspaceId must be a string","channelId must be a string","messageId should not be empty"] ', async () => {
             testNumber = 156;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 157 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 157;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 158 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 158;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 159 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 159;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 160 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 160;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 161 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 161;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 162 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 162;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 163 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 163;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 164 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 164;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 165 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string"] ', async () => {
             testNumber = 165;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 166 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 166;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 167 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 167;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 168 with expect errors ["workspaceId must be a string","channelId must be a string","messageId must be a string"] ', async () => {
             testNumber = 168;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 169 with expect errors ["workspaceId must be a string","channelId must be a string","content should not be empty"] ', async () => {
             testNumber = 169;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 170 with expect errors ["workspaceId must be a string","channelId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 170;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 171 with expect errors ["workspaceId must be a string","channelId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 171;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 172 with expect errors ["workspaceId must be a string","channelId must be a string","content should not be empty"] ', async () => {
             testNumber = 172;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 173 with expect errors ["workspaceId must be a string","channelId must be a string","content must be a string"] ', async () => {
             testNumber = 173;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 174 with expect errors ["workspaceId must be a string","channelId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 174;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 175 with expect errors ["workspaceId must be a string","channelId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 175;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 176 with expect errors ["workspaceId must be a string","channelId must be a string","content must be a string"] ', async () => {
             testNumber = 176;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 177 with expect errors ["workspaceId must be a string","channelId must be a string"] ', async () => {
             testNumber = 177;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 178 with expect errors ["workspaceId must be a string","channelId must be a string","ref should not be empty"] ', async () => {
             testNumber = 178;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 179 with expect errors ["workspaceId must be a string","channelId must be a string","ref must be a string"] ', async () => {
             testNumber = 179;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 180 with expect errors ["workspaceId must be a string","channelId must be a string"] ', async () => {
             testNumber = 180;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","channelId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 181 with expect errors ["workspaceId must be a string","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 181;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 182 with expect errors ["workspaceId must be a string","messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 182;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 183 with expect errors ["workspaceId must be a string","messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 183;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 184 with expect errors ["workspaceId must be a string","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 184;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 185 with expect errors ["workspaceId must be a string","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 185;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 186 with expect errors ["workspaceId must be a string","messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 186;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 187 with expect errors ["workspaceId must be a string","messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 187;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 188 with expect errors ["workspaceId must be a string","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 188;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 189 with expect errors ["workspaceId must be a string","messageId should not be empty"] ', async () => {
             testNumber = 189;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 190 with expect errors ["workspaceId must be a string","messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 190;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 191 with expect errors ["workspaceId must be a string","messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 191;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 192 with expect errors ["workspaceId must be a string","messageId should not be empty"] ', async () => {
             testNumber = 192;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 193 with expect errors ["workspaceId must be a string","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 193;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 194 with expect errors ["workspaceId must be a string","messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 194;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 195 with expect errors ["workspaceId must be a string","messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 195;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 196 with expect errors ["workspaceId must be a string","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 196;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 197 with expect errors ["workspaceId must be a string","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 197;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 198 with expect errors ["workspaceId must be a string","messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 198;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 199 with expect errors ["workspaceId must be a string","messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 199;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 200 with expect errors ["workspaceId must be a string","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 200;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 201 with expect errors ["workspaceId must be a string","messageId must be a string"] ', async () => {
             testNumber = 201;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 202 with expect errors ["workspaceId must be a string","messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 202;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 203 with expect errors ["workspaceId must be a string","messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 203;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 204 with expect errors ["workspaceId must be a string","messageId must be a string"] ', async () => {
             testNumber = 204;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 205 with expect errors ["workspaceId must be a string","content should not be empty"] ', async () => {
             testNumber = 205;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 206 with expect errors ["workspaceId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 206;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 207 with expect errors ["workspaceId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 207;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 208 with expect errors ["workspaceId must be a string","content should not be empty"] ', async () => {
             testNumber = 208;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 209 with expect errors ["workspaceId must be a string","content must be a string"] ', async () => {
             testNumber = 209;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 210 with expect errors ["workspaceId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 210;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 211 with expect errors ["workspaceId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 211;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 212 with expect errors ["workspaceId must be a string","content must be a string"] ', async () => {
             testNumber = 212;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 213 with expect errors ["workspaceId must be a string"] ', async () => {
             testNumber = 213;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 214 with expect errors ["workspaceId must be a string","ref should not be empty"] ', async () => {
             testNumber = 214;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 215 with expect errors ["workspaceId must be a string","ref must be a string"] ', async () => {
             testNumber = 215;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 216 with expect errors ["workspaceId must be a string"] ', async () => {
             testNumber = 216;
              totalTests++;
              const payloadObj = {"workspaceId":12345,"channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["workspaceId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 217 with expect errors ["channelId should not be empty","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 217;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 218 with expect errors ["channelId should not be empty","messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 218;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 219 with expect errors ["channelId should not be empty","messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 219;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 220 with expect errors ["channelId should not be empty","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 220;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 221 with expect errors ["channelId should not be empty","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 221;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 222 with expect errors ["channelId should not be empty","messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 222;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 223 with expect errors ["channelId should not be empty","messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 223;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 224 with expect errors ["channelId should not be empty","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 224;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 225 with expect errors ["channelId should not be empty","messageId should not be empty"] ', async () => {
             testNumber = 225;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 226 with expect errors ["channelId should not be empty","messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 226;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 227 with expect errors ["channelId should not be empty","messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 227;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 228 with expect errors ["channelId should not be empty","messageId should not be empty"] ', async () => {
             testNumber = 228;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 229 with expect errors ["channelId should not be empty","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 229;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 230 with expect errors ["channelId should not be empty","messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 230;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 231 with expect errors ["channelId should not be empty","messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 231;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 232 with expect errors ["channelId should not be empty","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 232;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 233 with expect errors ["channelId should not be empty","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 233;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 234 with expect errors ["channelId should not be empty","messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 234;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 235 with expect errors ["channelId should not be empty","messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 235;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 236 with expect errors ["channelId should not be empty","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 236;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 237 with expect errors ["channelId should not be empty","messageId must be a string"] ', async () => {
             testNumber = 237;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 238 with expect errors ["channelId should not be empty","messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 238;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 239 with expect errors ["channelId should not be empty","messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 239;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 240 with expect errors ["channelId should not be empty","messageId must be a string"] ', async () => {
             testNumber = 240;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 241 with expect errors ["channelId should not be empty","content should not be empty"] ', async () => {
             testNumber = 241;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 242 with expect errors ["channelId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 242;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 243 with expect errors ["channelId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 243;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 244 with expect errors ["channelId should not be empty","content should not be empty"] ', async () => {
             testNumber = 244;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 245 with expect errors ["channelId should not be empty","content must be a string"] ', async () => {
             testNumber = 245;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 246 with expect errors ["channelId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 246;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 247 with expect errors ["channelId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 247;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 248 with expect errors ["channelId should not be empty","content must be a string"] ', async () => {
             testNumber = 248;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 249 with expect errors ["channelId should not be empty"] ', async () => {
             testNumber = 249;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 250 with expect errors ["channelId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 250;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 251 with expect errors ["channelId should not be empty","ref must be a string"] ', async () => {
             testNumber = 251;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 252 with expect errors ["channelId should not be empty"] ', async () => {
             testNumber = 252;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"","messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 253 with expect errors ["channelId must be a string","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 253;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 254 with expect errors ["channelId must be a string","messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 254;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 255 with expect errors ["channelId must be a string","messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 255;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 256 with expect errors ["channelId must be a string","messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 256;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 257 with expect errors ["channelId must be a string","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 257;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 258 with expect errors ["channelId must be a string","messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 258;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 259 with expect errors ["channelId must be a string","messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 259;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 260 with expect errors ["channelId must be a string","messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 260;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 261 with expect errors ["channelId must be a string","messageId should not be empty"] ', async () => {
             testNumber = 261;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 262 with expect errors ["channelId must be a string","messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 262;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 263 with expect errors ["channelId must be a string","messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 263;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 264 with expect errors ["channelId must be a string","messageId should not be empty"] ', async () => {
             testNumber = 264;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 265 with expect errors ["channelId must be a string","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 265;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 266 with expect errors ["channelId must be a string","messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 266;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 267 with expect errors ["channelId must be a string","messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 267;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 268 with expect errors ["channelId must be a string","messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 268;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 269 with expect errors ["channelId must be a string","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 269;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 270 with expect errors ["channelId must be a string","messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 270;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 271 with expect errors ["channelId must be a string","messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 271;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 272 with expect errors ["channelId must be a string","messageId must be a string","content must be a string"] ', async () => {
             testNumber = 272;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 273 with expect errors ["channelId must be a string","messageId must be a string"] ', async () => {
             testNumber = 273;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 274 with expect errors ["channelId must be a string","messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 274;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 275 with expect errors ["channelId must be a string","messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 275;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 276 with expect errors ["channelId must be a string","messageId must be a string"] ', async () => {
             testNumber = 276;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 277 with expect errors ["channelId must be a string","content should not be empty"] ', async () => {
             testNumber = 277;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 278 with expect errors ["channelId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 278;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 279 with expect errors ["channelId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 279;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 280 with expect errors ["channelId must be a string","content should not be empty"] ', async () => {
             testNumber = 280;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 281 with expect errors ["channelId must be a string","content must be a string"] ', async () => {
             testNumber = 281;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 282 with expect errors ["channelId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 282;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 283 with expect errors ["channelId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 283;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 284 with expect errors ["channelId must be a string","content must be a string"] ', async () => {
             testNumber = 284;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 285 with expect errors ["channelId must be a string"] ', async () => {
             testNumber = 285;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 286 with expect errors ["channelId must be a string","ref should not be empty"] ', async () => {
             testNumber = 286;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 287 with expect errors ["channelId must be a string","ref must be a string"] ', async () => {
             testNumber = 287;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 288 with expect errors ["channelId must be a string"] ', async () => {
             testNumber = 288;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":12345,"messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["channelId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 289 with expect errors ["messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 289;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 290 with expect errors ["messageId should not be empty","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 290;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 291 with expect errors ["messageId should not be empty","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 291;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 292 with expect errors ["messageId should not be empty","content should not be empty"] ', async () => {
             testNumber = 292;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 293 with expect errors ["messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 293;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 294 with expect errors ["messageId should not be empty","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 294;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 295 with expect errors ["messageId should not be empty","content must be a string","ref must be a string"] ', async () => {
             testNumber = 295;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 296 with expect errors ["messageId should not be empty","content must be a string"] ', async () => {
             testNumber = 296;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 297 with expect errors ["messageId should not be empty"] ', async () => {
             testNumber = 297;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 298 with expect errors ["messageId should not be empty","ref should not be empty"] ', async () => {
             testNumber = 298;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 299 with expect errors ["messageId should not be empty","ref must be a string"] ', async () => {
             testNumber = 299;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 300 with expect errors ["messageId should not be empty"] ', async () => {
             testNumber = 300;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 301 with expect errors ["messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 301;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 302 with expect errors ["messageId must be a string","content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 302;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 303 with expect errors ["messageId must be a string","content should not be empty","ref must be a string"] ', async () => {
             testNumber = 303;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 304 with expect errors ["messageId must be a string","content should not be empty"] ', async () => {
             testNumber = 304;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 305 with expect errors ["messageId must be a string","content must be a string"] ', async () => {
             testNumber = 305;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 306 with expect errors ["messageId must be a string","content must be a string","ref should not be empty"] ', async () => {
             testNumber = 306;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 307 with expect errors ["messageId must be a string","content must be a string","ref must be a string"] ', async () => {
             testNumber = 307;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 308 with expect errors ["messageId must be a string","content must be a string"] ', async () => {
             testNumber = 308;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 309 with expect errors ["messageId must be a string"] ', async () => {
             testNumber = 309;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 310 with expect errors ["messageId must be a string","ref should not be empty"] ', async () => {
             testNumber = 310;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 311 with expect errors ["messageId must be a string","ref must be a string"] ', async () => {
             testNumber = 311;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 312 with expect errors ["messageId must be a string"] ', async () => {
             testNumber = 312;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":12345,"content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["messageId must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 313 with expect errors ["content should not be empty"] ', async () => {
             testNumber = 313;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 314 with expect errors ["content should not be empty","ref should not be empty"] ', async () => {
             testNumber = 314;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["content should not be empty","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 315 with expect errors ["content should not be empty","ref must be a string"] ', async () => {
             testNumber = 315;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["content should not be empty","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 316 with expect errors ["content should not be empty"] ', async () => {
             testNumber = 316;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["content should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 317 with expect errors ["content must be a string"] ', async () => {
             testNumber = 317;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 318 with expect errors ["content must be a string","ref should not be empty"] ', async () => {
             testNumber = 318;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["content must be a string","ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 319 with expect errors ["content must be a string","ref must be a string"] ', async () => {
             testNumber = 319;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["content must be a string","ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 320 with expect errors ["content must be a string"] ', async () => {
             testNumber = 320;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":12345,"ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["content must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 321 with expect errors [] ', async () => {
             testNumber = 321;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  [].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 322 with expect errors ["ref should not be empty"] ', async () => {
             testNumber = 322;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":""};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["ref should not be empty"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 323 with expect errors ["ref must be a string"] ', async () => {
             testNumber = 323;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":12345};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  ["ref must be a string"].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

           
            it('Test case # 324 with expect errors [] ', async () => {
             testNumber = 324;
              totalTests++;
              const payloadObj = {"workspaceId":"0","channelId":"{{channelId}}","messageId":"{{messageId}}","content":"test123_quote","ref":"ref"};
              resolvedData = resolveJsonVariables(payloadObj);
              
              const requestUrl = `${globalThis.url}/Message/QuoteMessage`;
            
            try {
              const response = await fetch(requestUrl, {
                method: 'post',
                headers: resolveJsonVariables(headerRequest),
                body: JSON.stringify(resolvedData)
              });

              const data = await response.json();

              if(response.status === 201){
              
                  expect(data.ok).toEqual(true)
                  expect(data.data).not.toBeNull()
                  const dtoInstance = plainToClass(QuoteMessageResponse, data);
                  const validateLogic = await validateQuoteMessage(dtoInstance, resolvedData);
                  if (validateLogic.length === 0) {
                    passedLogic++
                    passedTests++
                  } else {
                    logicTests.push({
                      testcase:testNumber,
                      errorLogic: validateLogic,
                    })
                  }
              }else if(response.status === 200){
                expect(data.ok).toEqual(true)
                passed200++
              
              }else if(response.status === 400){
                const expectJson =  [].sort()
                const expectDetails = Array.isArray(data?.error?.details)
                  ? data.error.details
                  : [];
                const softExpectDetails = [...expectDetails].sort();
                try {
                  expect(data.ok).toEqual(false);
                  expect(data.data).toEqual(null);
                  expect(expectJson).toEqual(softExpectDetails);
                  passedTests++;
                } catch (error) {
                  const { missing, extra } = summaryFields(error.matcherResult.actual, error.matcherResult.expected);
                  failedTests.push({
                    testcase: testNumber,
                    code: 400,
                    missing: missing || [],
                    extra: extra || []
                  })
                  throw new Error(error);
                }
              }else if (response.status === 500){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 500,
                  errorDetails: errorMessage,
                });
                throw new Error(errorMessage);
              }else if (response.status === 404){
                const errorMessage = data.error?.details;
                failedTests.push({
                  testcase:testNumber,
                  code: 404,
                  errorDetails: errorMessage,
                });
              } else {
                console.log('unexpected:', data);
                throw new Error(data);
              }
            }catch (error){

              if (error.message.includes('fetch failed')) {
              console.error('Network or server error:', error.message);
                failedTests.push({
                  testcase:testNumber,
                  errorDetails: 'Server down',
                });
                throw new Error('Server down');
              } else if (error.message.includes('Unexpected token')) {
                console.error('Could not resolve permission type', error.message);
                  failedTests.push({
                    testcase: testNumber,
                    code: 403,
                    errorDetails: 'Could not resolve permission type',
                  });
                throw new Error(error.message || 'unknown error');
              }else {
                throw new Error(error.message || 'unknown error');
              }
            }
            });

      afterAll(async () => {
        const folderPath = path.join(__dirname, '../reports');

        const folderPathLogic = path.join(__dirname, '../reports/quote-message');
        if (!fs.existsSync(folderPath)) {
          fs.mkdirSync(folderPath, { recursive: true });
        }
        if (!fs.existsSync(folderPathLogic)) {
          fs.mkdirSync(folderPathLogic, { recursive: true });
        }
        const summary = summarizeErrors(failedTests, totalTests, passedLogic, passed200);
        const resultContent = `
=== Test Reports for DTO "quote-message" ===
Host: ${globalThis.url}
Endpoint: /Message/QuoteMessage
Summary: 
Total Tests: ${totalTests}
Passed Tests: ${passedTests}
Failed Tests: ${failedTests.length}
Status Code:
  200: ${summary.statusCodes[200] || 0}
  201: ${summary.statusCodes[201] || 0}
  400: ${summary.statusCodes[400] || 0}
  403: ${summary.statusCodes[403] || 0}
  404: ${summary.statusCodes[404] || 0}
  500: ${summary.statusCodes[500] || 0}
Uniques Error:
  ${Array.from(summary.uniqueErrors.entries())
          .map(([error, count]) => `${error}: ${count} 
 `)
      .join('')
  }
Failed Test Details:
${failedTests.map((failCase) => `
  - Testcase #${failCase.testcase}
    Missing Errors: ${failCase.missing ? JSON.stringify(failCase.missing) : "''"}
    Status Code: ${failCase.code ? JSON.stringify(failCase.code) : "''"}
    Extra Errors: ${failCase.extra ? JSON.stringify(failCase.extra) : "''"}
    Detail Errors: ${failCase.errorDetails ? JSON.stringify(failCase.errorDetails) : "''"}`).join('')}`;


    const resultLogicError = `
    === Test Reports Logic for DTO "quote-message" ===
    Host: ${globalThis.url}
    Endpoint: /Message/QuoteMessage
    Error: 
    ${logicTests.map((logicCaseFail) => `
    - Testcase #${logicCaseFail.testcase}
      Logic Errors: ${logicCaseFail.errorLogic ? JSON.stringify(logicCaseFail.errorLogic) : "''"}
  ` ).join('')}`


const resultFilePath = path.join(folderPath, 'quote-message.txt');
const resultFilePathLogic = path.join(folderPathLogic, `quote-message.${getTime()}.txt`);
fs.writeFileSync(resultFilePath, resultContent, 'utf-8');
fs.writeFileSync(resultFilePathLogic, resultLogicError, 'utf-8');
console.log(`Success: ${resultFilePath}`);
await executeDelete(undefined, headerRequest)    
});
                          
                    });

                